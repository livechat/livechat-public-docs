---
weight: 60
category: "extending-chat-widget"
subcategory: "custom-identity-provider"
title: "Custom Identity Provider"
tagline: "Pair your own customer identity with LiveChat"
desc: "Cross-platform chats for your applications"
versionGroup: "chat-widget"
---

# Introduction

## What is it for?

If you have a more advanced service, handling user sessions, you can pair LiveChat customer identity with your own. As a result, your customers will never lose chats they made with your support. What is more, if you also use LiveChat on other platfroms (e.g., in mobile applications), their conversations will sync, making the communication even more seamless and natural.

## Setup
Customer Identity Provider is essentially a singleton function. You can define as a part of `LiveChatWidget` object from the tracking code used to install ChatWidget on your website or any other place accessing `window.__lc` object, however - **it has to be provided before widget initialization**.

```js
    // Custom Identity Provider
    window.__lc.custom_identity_provider = function() {
      return {
          getToken: ...,
          getFreshToken: ...,
          hasToken: ...,
          invalidate: ...
      }
    }
```

# Methods

The aforementioned function assigned to `custom_identity_provider` property should return a set of the following promises:

- `getToken` - resolving [Chat Widget token](#chat-widget-token). If you want to cache the token somehow, this should return the cached token instead of a fresh request to API.
- `getFreshToken` - resolving [Chat Widget token](#chat-widget-token). This should always make a call for a fresh token from accounts API.
- `hasToken` - resolving boolean. Determining whether a token has been acquired.
- `invalidate` - resolving nothing. When called should remove the current token. There is no need to do anything else, as a new token will be requested by `getFreshToken` afterward.

# Chat Widget Token

LiveChat authorization token you are willing to resolve in functions should contain the following properties:

| Parameter      | Description                                                                      |
| -------------- | -------------------------------------------------------------------------------- |
| `accessToken`  | A token you can use to call LiveChat APIs on behalf of the user (customer).      |
| `entityId`     | The ID of the customer.                                                              |
| `expiresIn`    | A number in **milliseconds** specifying how long the `accessToken` will be valid.|
| `tokenType`    | Value: `Bearer`.                                                                 |
| `creationDate` | Unix timestamp specyfing the time of creation of the token.                       |
| `licenseId`    | LiveChat license ID.                                                             |

## How to acquire it?

In order to get the token you need to implement authorizing function making a call to a `/customer` endpoint from LiveChat Accounts API. To do so, you can follow [creating a new customer flow](https://developers.livechat.com/docs/authorization/authorizing-api-calls/#creating-a-new-customer) or have a look at our [example](https://github.com/livechat/identity-provider-example/blob/master/lib/get-customer-token.ts) using cookies. Mind the fact that the [data](https://developers.livechat.com/docs/authorization/authorizing-api-calls/#response-4) returned from this endpoint is not 1:1 with the token shape described above. You will have to add the `creationDate` and `licenseId` fields. Additionally, we expect `expiresIn` to be defined in milliseconds while the endpoint operates in seconds. Therefore you should multiply the provided value by `1000` before passing it further.


# Examples

Here are our suggested implementations of Customer Identity Provider. The `fetchLiveChatToken()` method used in examples is used to acquire the [Chat Widget token](#chat-widget-token).

## Without caching

If you don't need to cache the token, the fetching logic shall occur on every refresh of your application page. In such a case, the implementation can be very simple - we only have to ensure handling of `getToken` promise and simply resolve others.

```js
 window.__lc.custom_identity_provider = () => {
    const fetchLiveChatToken = () => {
        // fetch a token from LiveChat Accounts API here
    }

    let tokenPromise = null
    const fetchToken = () => {
        tokenPromise = fetchLiveChatToken()
            .then(response => {
                tokenPromise = null
                return response
            })
    }

    return {
        getToken: () => tokenPromise || fetchToken(),
        getFreshToken: () => Promise.resolve(),
        hasToken: () => Promise.resolve(false),
        invalidate: () => Promise.resolve()
    }
 }
```

## With caching

If you care about the number of requests being made in your application, you can unleash the full potential of the Custom Identity Provider.

```js
window.__lc.custom_identity_provider = () => {
    const fetchLiveChatToken = () => {
        // fetch a token from LiveChat Accounts API here
    }

    const cacheKey = 'YOUR_CACHE_KEY'
    let tokenPromise = null
    let cachedToken = null

    const isExpired = ({ creationDate, expiresIn }) => Date.now() >= creationDate + expiresIn

    let retrievingToken = window.sessionStorage.getItem(cacheKey).then(token => {
        if (!retrievingToken) {
            return
        }

        retrievingToken = null

        if (!token) {
            return
        }

        cachedToken = JSON.parse(token)
    })

    const getToken = () => {
        if (pendingTokenRequest) {
			return pendingTokenRequest
		}

		if (cachedToken && !isExpired(cachedToken)) {
			return Promise.resolve(cachedToken)
		}

		if (retrievingToken) {
			return retrievingToken.then(getToken)
		}

		return getFreshToken()
    }

    const getFreshToken = () => {
        tokenPromise = fetchLiveChatToken().then(
            token => {
                pendingTokenRequest = null
                window.sessionStorage.setItem(cacheKey, JSON.stringify(token))
                cachedToken = token
                return token
            }
        )
    }

    const hasToken = () => {
		if (retrievingToken) {
			return retrievingToken.then(hasToken)
		}

		return Promise.resolve(!!cachedToken)
	}

	const invalidate = () => {
		cachedToken = null
		retrievingToken = null
		return storage.removeItem(cacheKey)
	}

    return {
		getToken,
        getFreshToken,
		hasToken,
		invalidate,
    }
 }
```

## Repository

Still hungry for knowledge? We have also prepared the example application presenting the usage of the Custom Identity Provider mechanism. You can check it out [here](https://github.com/livechat/identity-provider-example/).

